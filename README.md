# JOG

JOG is a framework that facilitates developing Java JIT peephole
optimizations alongside JIT tests. JOG enables developers to write a
pattern, in Java itself, that specifies desired code transformations
by writing code before and after the optimization, as well as any
necessary preconditions. Such patterns can be written in the same way
that tests of the optimization are already written in OpenJDK. JOG
translates each pattern into C/C++ code that can be integrated as a
JIT optimization pass. JOG also generates Java tests for optimizations
from patterns. Furthermore, JOG can automatically detect possible
shadow relation between a pair of optimizations where the effect of
the shadowed optimization is overridden by another.

## Table of contents

1. [Requirements](#Requirements)
2. [Example](#Example)
3. [Hall of Fame](#Hall-of-Fame)
4. [Citation](#Citation)
5. [Contact](#Contact)

## Requirements

- Linux with GNU Bash (tested on Ubuntu 20.04)
- JDK >=11

## Example

Developers write Java JIT peephole optimizations in _patterns_, using
JOG's DSL fully embedded in Java. For example, `Example.java` contains
two patterns `ADD2` and `ADD8`. `ADD2` represents a peephole
optimization that transforms `(a - b) + (c - d)` to `(a + c) - (b +
d)`, and `ADD8` expresses a peephole optimization that transforms
`(a - b) + (c - a)` to `(c - b)`.

```java
import jog.api.*;

import static jog.api.Action.*;

public class Example {

    @Pattern
    public void ADD2(long a, long b, long c, long d) {
        before((a - b) + (c - d));
        after((a + c) - (b + d));
    }

    @Pattern
    public void ADD8(long a, long b, long c) {
        before((a - b) + (c - a));
        after(c - b);
    }
}
```

From the patterns, JOG

1. Generates C/C++ code that can be integrated as JIT optimization
   pass.

   JOG translates every pattern into corresponding optimization pass
   in C/C++.

   `gen-code/addnode.cpp`
   ```cpp
   /* Automatically generated by jog from patterns:
   ADD2,
   ADD8. */
   Node* AddLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
   // ADD2
   {
   Node* _JOG_in1 = in(1);
   Node* _JOG_in11 = _JOG_in1 != NULL && 1 < _JOG_in1->req() ? _JOG_in1->in(1) : NULL;
   Node* _JOG_in12 = _JOG_in1 != NULL && 2 < _JOG_in1->req() ? _JOG_in1->in(2) : NULL;
   Node* _JOG_in2 = in(2);
   Node* _JOG_in21 = _JOG_in2 != NULL && 1 < _JOG_in2->req() ? _JOG_in2->in(1) : NULL;
   Node* _JOG_in22 = _JOG_in2 != NULL && 2 < _JOG_in2->req() ? _JOG_in2->in(2) : NULL;
   if (_JOG_in1->Opcode() == Op_SubL
       && _JOG_in2->Opcode() == Op_SubL) {
   return new SubLNode(phase->transform(new AddLNode(_JOG_in11, _JOG_in21)), phase->transform(new AddLNode(_JOG_in12, _JOG_in22)));
   }
   }

   // ADD8
   {
   Node* _JOG_in1 = in(1);
   Node* _JOG_in11 = _JOG_in1 != NULL && 1 < _JOG_in1->req() ? _JOG_in1->in(1) : NULL;
   Node* _JOG_in12 = _JOG_in1 != NULL && 2 < _JOG_in1->req() ? _JOG_in1->in(2) : NULL;
   Node* _JOG_in2 = in(2);
   Node* _JOG_in21 = _JOG_in2 != NULL && 1 < _JOG_in2->req() ? _JOG_in2->in(1) : NULL;
   Node* _JOG_in22 = _JOG_in2 != NULL && 2 < _JOG_in2->req() ? _JOG_in2->in(2) : NULL;
   if (_JOG_in1->Opcode() == Op_SubL
       && _JOG_in2->Opcode() == Op_SubL
       && _JOG_in11 == _JOG_in22) {
   return new SubLNode(_JOG_in21, _JOG_in12);
   }
   }
   }
   ```

2. Generates Java tests that can be used to test such optimizations.

   The IR test, written in Java using
   [IR test framework](https://github.com/openjdk/jdk/tree/master/test/hotspot/jtreg/compiler/lib/ir_framework),
   is a recommended approach in OpenJDK to testing JIT peephole
   optimizations. JOG can automatically generate a IR test from every
   pattern.

   `gen-tests/TestAddLNode.java`
   ```java
   /*Automatically generated by jog from patterns:
   ADD2,
   ADD8.*/
   package compiler.c2.irTests;

   import jdk.test.lib.Asserts;
   import compiler.lib.ir_framework.*;

   /*@test
   @library /test/lib /
   @run driver compiler.c2.irTests.TestAddLNode*/
   public class TestAddLNode {

       public static void main(String[] args) {
           TestFramework.run();
       }

       @Run(test = { "testADD2", "testADD8" })
       public void runMethod() {
           long a = RunInfo.getRandom().nextLong();
           long b = RunInfo.getRandom().nextLong();
           long c = RunInfo.getRandom().nextLong();
           long d = RunInfo.getRandom().nextLong();
           long min = Long.MIN_VALUE;
           long max = Long.MAX_VALUE;
           assertResult(0, 0, 0, 0);
           assertResult(a, b, c, d);
           assertResult(min, min, min, min);
           assertResult(max, max, max, max);
       }

       @DontCompile
       public void assertResult(long a, long b, long c, long d) {
           Asserts.assertEQ((a - b) + (c - d), testADD2(a, b, c, d));
           Asserts.assertEQ((a - b) + (c - a), testADD8(a, b, c));
       }

       // Checks (a - b) + (c - d) => (a + c) - (b + d)
       @Test
       @IR(counts = { IRNode.ADD, "2", IRNode.SUB, "1" })
       public long testADD2(long a, long b, long c, long d) {
           return (a - b) + (c - d);
       }

       // Checks (a - b) + (c - a) => c - b
       @Test
       @IR(failOn = { IRNode.ADD })
       @IR(counts = { IRNode.SUB, "1" })
       public long testADD8(long a, long b, long c) {
           return (a - b) + (c - a);
       }
   }
   ```

3. Detects any possible shadow relation between a pair of
   optimizations.

   Note that any expression matching `(a - b) + (c - a)` (`ADD2`) also
   matches `(a - b) + (c - d)` (`ADD8`), which means `ADD2` can be
   applied wherever `ADD8` can be applied, so the effect of `ADD2`
   will shadow `ADD8` if `ADD2` is always applied before `ADD8` in a
   compiler pass. JOG can automatically report the shadow relations.

   `shadows.yml`
   ```
   -
     shadowing:
       name: ADD2
       before: "(a - b) + (c - d)"
       precondition: []
     shadowed:
       -
         name: ADD8
         before: "(a - b) + (c - a)"
         precondition: []
   ```

To run the example, please run `./example.sh`:
```bash
$ ./example.sh
Building JOG...
Reading the patterns from file Example.java...
Generated C++ code saved in gen-code/.
Generated Tests saved in gen-tests/.
Shadow relations reported in shadows.yml.
```

# Hall Of Fame

Here is the list of pull requests we opened for OpenJDK:

New optimizations:

- [#6441](https://github.com/openjdk/jdk/pull/6441):
  8277882: New subnode ideal optimization: converting "c0 - (x + c1)"
  into "(c0 - c1) - x".

- [#6675](https://github.com/openjdk/jdk/pull/6675):
  8278114: New addnode ideal optimization: converting "x + x" into "x
  << 1".

- [#6858](https://github.com/openjdk/jdk/pull/6858):
  8279607: Existing optimization "~x+1" -> "- x" can be generalized to
  "~x+c" -> "(c-1)-x".

- [#7795](https://github.com/openjdk/jdk/pull/7795):
  8283094: Add Ideal transformation: x + (con - y) -> (x - y) + con.

- [#7376](https://github.com/openjdk/jdk/pull/7376):
  8281453: New optimization: convert ~x into -1-x when ~x is used in
  an arithmetic expression.

- [#7395](https://github.com/openjdk/jdk/pull/7395):
  8281518: New optimization: convert "(x|y)-(x^y)" into "x&y".

New tests:

- [#11049](https://github.com/openjdk/jdk/pull/11049):
  8297384: Add IR tests for existing idealizations of arithmetic
  nodes.

Fix detected shadowed optimizations:

- [#6752](https://github.com/openjdk/jdk/pull/6752):
  8278471: Remove unreached rules in AddNode::IdealIL.

## Citation

If you use JOG in your research, we request you to cite our
[ISSTA'23 paper](https://cptgit.github.io/dl/papers/zang23jog.pdf).
Thank you!

```bibtex
@inproceedings{zang23jog,
  author = {Zang, Zhiqiang and Thimmaiah, Aditya and Gligoric, Milos},
  title = {{Pattern-Based Peephole Optimizations with {J}ava {JIT} Tests}},
  booktitle = {International Symposium on Software Testing and Analysis},
  pages = {to appear},
  year= {2023},
  doi = {to appear},
}
```

## Contact

Let me ([Zhiqiang Zang](https://github.com/CptGit)) know if you have
any questions.
