package jog.codegen;

import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.stmt.Statement;
import jog.Constants;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 * Multiple patterns grouped together, annotated with
 * {@link Constants#GROUP_ANNOT}.
 */
public class GroupV extends Translatable {

    // All patterns
    private final List<PatternV> patterns;

    // Used patter calls in this @Group method
    private Map<String, PatternV> patternByName;
    private List<String> patternNames;

    public GroupV(MethodDeclaration methodDecl, List<PatternV> patterns) {
        super(methodDecl, Constants.GROUP_ANNOT);
        this.patterns = patterns;
        init();
    }

    @Override
    public void translate() {
        translationBuilder = new StringBuilder();
        translationBuilder.append("/* Automatically generated by jog. */\n");
        translationBuilder.append("Node* ")
                .append("SubINode::")
                .append(methodDecl.getNameAsString())
                .append("(PhaseGVN *phase, bool can_reshape) {\n");
        if (methodDecl.getBody().isEmpty()) {
            translationBuilder.append("}\n");
            return;
        }
        // Generate one function call for each pattern
        for (String name : patternNames) {
            PatternV pattern = patternByName.get(name);
            pattern.translate();
            translationBuilder.append("// ").append(name).append("\n");
            translationBuilder.append(pattern.getTranslation());
        }
        translationBuilder.append("}\n");
    }

    private void init() {
        if (methodDecl.getBody().isEmpty()) {
            return;
        }
        // Map pattern name to pattern instance
        patternByName = new HashMap<>();
        for (PatternV pattern : patterns) {
            String name = pattern.getMethodDecl().getNameAsString();
            patternByName.put(name, pattern);
        }
        scanAllPatternCalls();
    }

    /**
     * Scan all pattern calls in this @Group method.
     */
    private void scanAllPatternCalls() {
        patternNames = new LinkedList<>();
        for (Statement stmt : methodDecl.getBody().get().getStatements()) {
            if (isPatternCallStmt(stmt)) {
                patternNames.add(getPatternName(stmt));
            }
        }
    }

    private static String getPatternName(Statement stmt) {
        return stmt.asExpressionStmt().getExpression().asMethodCallExpr().getNameAsString();
    }

    private boolean isPatternCallStmt(Statement stmt) {
        return stmt.isExpressionStmt()
                && isPatternCallExpr(stmt.asExpressionStmt().getExpression());
    }

    private boolean isPatternCallExpr(Expression expr) {
        return expr.isMethodCallExpr()
                && patternByName.containsKey(expr.asMethodCallExpr().getNameAsString());
    }
}
