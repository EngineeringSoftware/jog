package jog.codegen;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.StringLiteralExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import jog.ast.expr.BinNode;
import jog.ast.visitor.CodeGenUtil.ValType;
import jog.util.IOUtil;
import jog.util.JPUtil;
import jog.util.MiscUtil;

import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class TestClassGen {

    private final BinNode.NodeType type;
    private final List<PatternV> patterns;
    private final List<TestMethodGen> testMethodGens;
    private final Map<String, String> paramToArg;
    private final String outputDir;
    private final ValType valType;

    public TestClassGen(BinNode.NodeType type, Collection<PatternV> patterns, String outputDir) {
        if (patterns.isEmpty()) {
            throw new IllegalArgumentException("No patterns to test.");
        }
        Set<ValType> valTypes = patterns.stream()
                .map(PatternV::getValType)
                .collect(Collectors.toSet());
        if (valTypes.size() != 1) {
            throw new IllegalArgumentException("Patterns have different value types.");
        }
        this.valType = valTypes.iterator().next();
        this.type = type;
        this.patterns = new LinkedList<>(patterns);
        this.testMethodGens = patterns.stream()
                .map(PatternV::getTestMethodGen)
                .collect(Collectors.toList());
        this.paramToArg = findTestMethodWithMostParams();
        this.outputDir = outputDir;
        IOUtil.createDir(outputDir);
    }

    public void generateTestCode() {
        CompilationUnit cu = StaticJavaParser.parse(
                "package compiler.c2.irTests;" +
                        "import jdk.test.lib.Asserts;" +
                        "import compiler.lib.ir_framework.*;" +
                        "public class " + getTestClassName() + "{" +
                        "public static void main(String[] args) {" +
                        "TestFramework.run();" +
                        "}" +
                        "}");
        cu.setBlockComment("Automatically generated by jog from patterns: \n" +
                patterns.stream()
                        .map(PatternV::getName)
                        .collect(Collectors.joining(",\n"))
                + ".");
        ClassOrInterfaceDeclaration testClass = cu.getClassByName(getTestClassName()).get();
        testClass.setBlockComment("@test\n" + "@library /test/lib /\n" + "@run driver compiler.c2.irTests." + getTestClassName());
        testClass.addMember(generateMethodRunMethod());
        testClass.addMember(generateMethodAssertResult());
        for (TestMethodGen tmg : testMethodGens) {
            testClass.addMember(tmg.getTestMethod());
        }
        IOUtil.writeToJavaFile(outputDir, getTestClassName(), cu.toString());
    }

    /**
     * Generate method runMethod.
     */
    private MethodDeclaration generateMethodRunMethod() {
        List<Expression> testNames = patterns.stream()
                .map(p -> new StringLiteralExpr(p.getTestMethodGen().getTestMethodName()))
                .collect(Collectors.toList());
        MethodDeclaration m = StaticJavaParser.parseMethodDeclaration(
                "@Run(test = " + JPUtil.arrayInitExpr(new NodeList<>(testNames)) + ")\n" +
                        "public void runMethod() {" +
                        "}");
        BlockStmt block = m.getBody().get();
        String valTypeName = valType.getTypeName();
        for (String arg : paramToArg.values()) {
            block.addStatement(
                valTypeName + " " + arg + " = RunInfo.getRandom().next" + valType.getCapitalizedTypeName() + "();");
        }
        String valBoxedTypeName = valType.getBoxedTypeName();
        block.addStatement(valTypeName + " min = " + valBoxedTypeName + ".MIN_VALUE;");
        block.addStatement(valTypeName + " max = " + valBoxedTypeName + ".MAX_VALUE;");
        int nArgs = paramToArg.size();
        block.addStatement("assertResult(" + String.join(", ", Collections.nCopies(nArgs, "0")) + ");");
        block.addStatement("assertResult(" + String.join(",", paramToArg.values()) + ");");
        block.addStatement("assertResult(" + String.join(", ", Collections.nCopies(nArgs, "min")) + ");");
        block.addStatement("assertResult(" + String.join(", ", Collections.nCopies(nArgs, "max")) + ");");
        return m;
    }

    /**
     * Generate method assertResult.
     */
    private MethodDeclaration generateMethodAssertResult() {
        MethodDeclaration m = StaticJavaParser.parseMethodDeclaration(
                "@DontCompile\n" + "public void assertResult("
                + MiscUtil.makeParamDeclList(paramToArg.values(), valType)
                + ") {}");
        for (TestMethodGen tmg : testMethodGens) {
            m.getBody().get().addStatement(tmg.getAssertion());
        }
        return m;
    }

    private Map<String, String> findTestMethodWithMostParams() {
        int max = 0;
        Map<String, String> maxParamToArg = null;
        for (TestMethodGen testMethodGen : testMethodGens) {
            Map<String, String> paramToArg = testMethodGen.getParamToArg();
            if (max < paramToArg.size()) {
                maxParamToArg = paramToArg;
                max = paramToArg.size();
            }
        }
        return maxParamToArg;
    }

    private String getTestClassName() {
        return "Test" + type.toCodeGen(valType);
    }
}
